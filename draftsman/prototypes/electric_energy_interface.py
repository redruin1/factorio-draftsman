# electric_energy_interface.py

# TODO: would be nice to have the correct defaults applied in the format itself,
# so that the fields would be correctly omitted when converting to_dict with
# exclude_defaults=True
# Currently we just override to_dict, but this is far from elegant

from draftsman.classes.entity import Entity
from draftsman.classes.exportable import attempt_and_reissue
from draftsman.classes.vector import Vector, PrimitiveVector
from draftsman.constants import ValidationMode
from draftsman.utils import parse_energy

from draftsman.data.entities import electric_energy_interfaces
from draftsman.data import entities

from pydantic import ConfigDict, Field
from typing import Any, Literal, Optional, Union


class ElectricEnergyInterface(Entity):
    """
    An entity that interfaces with an electrical grid.
    """

    class Format(Entity.Format):
        buffer_size: Optional[float] = Field(
            None,  # Entity specific default
            description="""
            The energy capacity of this entity in Joules, from which it can 
            charge or discharge. Defaults to the 'buffer_capacity' value in
            the associated entity's 'energy_source' key in data.raw. 
            """,
        )
        power_production: Optional[float] = Field(
            None,  # Entity specific default
            description="""
            The amount of energy in Joules generated by this entity every tick.
            Defaults to the 'energy_production' key in this entity's data.raw
            entry.
            """,
        )
        power_usage: Optional[float] = Field(
            None,  # Entity specific default
            description="""
            The amount of energy in Joules used by this entity every tick.
            Defaults to the 'energy_usage' key in this entity's data.raw entry.
            """,
        )

        model_config = ConfigDict(title="ElectricEnergyInterface")

    def __init__(
        self,
        name=electric_energy_interfaces[0],
        position: Union[Vector, PrimitiveVector] = None,
        tile_position: Union[Vector, PrimitiveVector] = (0, 0),
        buffer_size: float = None,
        power_production: float = None,
        power_usage: float = None,
        tags: dict[str, Any] = {},
        validate: Union[
            ValidationMode, Literal["none", "minimum", "strict", "pedantic"]
        ] = ValidationMode.STRICT,
        validate_assignment: Union[
            ValidationMode, Literal["none", "minimum", "strict", "pedantic"]
        ] = ValidationMode.STRICT,
        **kwargs
    ):
        """
        TODO
        """

        self._root: __class__.Format

        super().__init__(
            name,
            electric_energy_interfaces,
            position=position,
            tile_position=tile_position,
            tags=tags,
            **kwargs
        )

        if buffer_size is None:
            self.buffer_size = self.default_buffer_size
        else:
            self.buffer_size = buffer_size

        if power_production is None:
            self.power_production = self.default_power_production
        else:
            self.power_production = power_production

        if power_usage is None:
            self.power_usage = self.default_power_usage
        else:
            self.power_usage = power_usage

        self.validate_assignment = validate_assignment

        if validate:
            self.validate(mode=validate).reissue_all(stacklevel=3)

    # =========================================================================

    @property
    def default_buffer_size(self) -> Optional[float]:
        """
        TODO
        """
        energy_string = (
            entities.raw.get(self.name, {})
            .get("energy_source", {})
            .get("buffer_capacity", None)
        )
        if energy_string is None:
            return None
        else:
            return parse_energy(energy_string)

    # =========================================================================

    @property
    def default_power_production(self) -> Optional[float]:
        """
        TODO
        """
        energy_string = entities.raw.get(self.name, {}).get("energy_production", None)
        if energy_string is None:
            return None
        else:
            return parse_energy(energy_string)

    # =========================================================================

    @property
    def default_power_usage(self) -> Optional[float]:
        """
        TODO
        """
        energy_string = entities.raw.get(self.name, {}).get("energy_usage", None)
        if energy_string is None:
            return None
        else:
            return parse_energy(energy_string)

    # =========================================================================

    @property
    def buffer_size(self) -> Optional[float]:
        """
        The amount of electrical energy stored in this entity in Watts.

        :getter: Gets the value of the buffer.
        :setter: Sets the value of the buffer.
        :type: ``int``

        :exception TypeError: If set to anything other than an ``int`` or
            ``None``.
        """
        return self._root.buffer_size

    @buffer_size.setter
    def buffer_size(self, value: Optional[float]):
        # type: (int) -> None
        if self.validate_assignment:
            result = attempt_and_reissue(
                self, type(self).Format, self._root, "buffer_size", value
            )
            self._root.buffer_size = result
        else:
            self._root.buffer_size = value

    # =========================================================================

    @property
    def power_production(self) -> Optional[float]:
        """
        The amount of electrical energy to create each tick in Watts.

        :getter: Gets how much to make.
        :setter: Sets how much to make.
        :type: ``int``

        :exception TypeError: If set to anything other than an ``int`` or
            ``None``.
        """
        return self._root.power_production

    @power_production.setter
    def power_production(self, value: Optional[float]):
        if self.validate_assignment:
            result = attempt_and_reissue(
                self, type(self).Format, self._root, "power_production", value
            )
            self._root.power_production = result
        else:
            self._root.power_production = value

    # =========================================================================

    @property
    def power_usage(self) -> Optional[float]:
        """
        The amount of electrical energy to use each tick in Watts.

        :getter: Gets how much to use.
        :setter: Sets how much to use.
        :type: ``int``

        :exception TypeError: If set to anything other than an ``int`` or
            ``None``.
        """
        return self._root.power_usage

    @power_usage.setter
    def power_usage(self, value: Optional[float]):
        if self.validate_assignment:
            result = attempt_and_reissue(
                self, type(self).Format, self._root, "power_usage", value
            )
            self._root.power_usage = result
        else:
            self._root.power_usage = value

    # =========================================================================

    def to_dict(self, exclude_none: bool = True, exclude_defaults: bool = True) -> dict:
        result = super().to_dict(
            exclude_none=exclude_none, exclude_defaults=exclude_defaults
        )

        if exclude_defaults:
            if result.get("buffer_size", None) == self.default_buffer_size:
                del result["buffer_size"]
            if result.get("power_production", None) == self.default_power_production:
                del result["power_production"]
            if result.get("power_usage", None) == self.default_power_usage:
                del result["power_usage"]

        return result

    def merge(self, other: "ElectricEnergyInterface"):
        super().merge(other)

        self.buffer_size = other.buffer_size
        self.power_production = other.power_production
        self.power_usage = other.power_usage

    # =========================================================================

    __hash__ = Entity.__hash__

    def __eq__(self, other) -> bool:
        return (
            super().__eq__(other)
            and self.buffer_size == other.buffer_size
            and self.power_production == other.power_production
            and self.power_usage == other.power_usage
        )
