# directional.py

from draftsman.classes.collision_set import CollisionSet
from draftsman.classes.exportable import Exportable
from draftsman.constants import (
    Direction,
    ValidationMode,
)
from draftsman.data import entities
from draftsman.serialization import draftsman_converters
from draftsman.validators import conditional, instance_of, try_convert
from draftsman.utils import aabb_to_dimensions, get_first
from draftsman.warning import DirectionWarning

import attrs
from typing import Any, Optional
import warnings

from typing import TYPE_CHECKING

if TYPE_CHECKING:  # pragma: no coverage
    from draftsman.classes.entity import Entity

# Instead of storing a unique collision set for every entity, only store one for
# every single unique direction that an entity has and point here as necessary.
# Finalized, per-instance collision sets can then be generated by calling
# `Entity.get_world_collision_set()`.
_rotated_collision_sets: dict[str, list[CollisionSet]] = {}


@attrs.define(slots=False)
class DirectionalMixin(Exportable):
    """
    Permits this entity to be able to specify its :py:attr:`.direction`
    attribute, a discrete rotation value. Exactly how many directions an entity
    can occupy (no-rotation, 4-way, 8-way, 16-way) is determined via it's
    :py:attr:`~.Entity.flags`.

    All entities are directional, except for vehicle/rolling stock entities,
    which instead have an ``orientation``.

    .. seealso::

        :py:class:`~.OrientationMixin`
    """

    def __attrs_pre_init__(self, name=attrs.NOTHING, first_call=None, **kwargs):
        # Make sure this is the first time calling pre-init (bugfix until attrs
        # is patched)
        if not first_call:
            return

        # Call parent pre-init
        # super().__attrs_pre_init__()
        # name = kwargs.get("name", get_first(self.similar_entities))
        name = name if name is not attrs.NOTHING else get_first(self.similar_entities)
        object.__setattr__(self, "name", name)

        # We generate collision sets on an as-needed basis for each unique
        # entity that is instantiated
        # Automatically generate a set of rotated collision sets for every
        # orientation
        try:
            _rotated_collision_sets[name]
        except KeyError:
            static_collision_set = entities.collision_sets.get(name, None)
            _rotated_collision_sets[name] = {}
            for i in self.valid_directions:
                if self.collision_set_rotated and static_collision_set is not None:
                    # closest_direction = i.to_closest_valid_direction(
                    #     self.valid_directions
                    # )
                    rotated_collision_set = static_collision_set.rotate(i)
                else:
                    rotated_collision_set = static_collision_set

                _rotated_collision_sets[name][i] = rotated_collision_set

            # if self.collision_set_rotated:
            #     # Automatically generate a set of rotated collision sets for every
            #     # orientation
            #     # TODO: would probably be better to do this in env.py, but how?
            #     static_collision_set = entities.collision_sets.get(name, None)
            #     if static_collision_set:
            #         _rotated_collision_sets[name] = {}
            #         for i in self.valid_directions:
            #             _rotated_collision_sets[name][i] = static_collision_set.rotate(i)
            #     else:
            #         _rotated_collision_sets[name] = {}
            #         for i in self.valid_directions:
            #             _rotated_collision_sets[name][i] = None
            # else:
            #     # populate the `_rotated_collision_sets` dict, put have all entries
            #     # point to the same item so we don't use too much memory
            #     _rotated_collision_sets[name] = static_collision_set
            #     # for i in self.valid_directions:
            #     #     _rotated_collision_sets[name][i] = known_collision_set

        # The default position function uses `tile_width`/`tile_height`, which
        # use `collision_set`, which for rotatable entities is derived from the
        # current `direction`. However, since direction is specified *after*
        # position sequentially (and there is no way to easily rearrange them
        # since they are inherited), we need to manually "patch" the given value
        # of direction before the rest of the attribute setting code has run.
        # We use `object.__setattr__()` to circumvent the fact that we gave
        # `direction` a custom setattr function and mimic a "raw" attribute set.
        direction = kwargs.get("direction", Direction.NORTH)
        object.__setattr__(self, "direction", direction)

    # =========================================================================

    @property
    def rotatable(self) -> bool:
        try:
            # If the base prototype has a concept of direction, whether or not
            # this particular entity can rotate is determined by the
            # "not-rotatable" flag
            return "not-rotatable" not in self.flags
        except TypeError:
            # In the unknown case, take the flexible option and assume that the
            # entity may enable direction
            return True

    # =========================================================================

    @property
    def collision_set_rotated(self) -> bool:
        """
        Whether or not this entity actually has their collision set rotated by
        their direction. Some entities (such as rail signals) have many valid
        directions they can exist as but reuse the same collision set for all of
        them. Not exported; read only.
        """
        return self.rotatable and not self.square

    # =========================================================================

    # @property
    # def valid_directions(self) -> set[Direction]:
    #     """
    #     A set containing all directions that this entity can face. Not exported;
    #     read only.
    #     """
    #     """
    #     A set containing all directions that this entity can face. Not exported;
    #     read only.
    #     """
    #     if not self.rotatable:
    #         return {Direction.NORTH}
    #     try:
    #         if "building-direction-8-way" in self.flags:
    #             return EIGHT_WAY_DIRECTIONS
    #         elif "building-direction-16-way" in self.flags:
    #             return SIXTEEN_WAY_DIRECTIONS
    #         else:
    #             return FOUR_WAY_DIRECTIONS
    #     except TypeError:
    #         # In the unknown case, assume that the entity could occupy any valid
    #         # direction
    #         return SIXTEEN_WAY_DIRECTIONS

    # =========================================================================

    @property
    def collision_set(self) -> Optional[CollisionSet]:
        return _rotated_collision_sets.get(self.name, {}).get(
            self.direction.to_closest_valid_direction(self.valid_directions), None
        )

    # =========================================================================

    @property  # Cache?
    def tile_width(self) -> int:
        if "tile_width" in self.prototype and "tile_height" in self.prototype:
            if self.direction in {Direction.EAST, Direction.WEST}:  # TODO: more generic
                return self.prototype["tile_height"]
            else:
                return self.prototype["tile_width"]
        else:
            return aabb_to_dimensions(
                self.collision_set.get_bounding_box() if self.collision_set else None
            )[0]

    # =========================================================================

    @property  # Cache?
    def tile_height(self) -> int:
        if "tile_width" in self.prototype and "tile_height" in self.prototype:
            if self.direction in {Direction.EAST, Direction.WEST}:  # TODO: more generic
                return self.prototype["tile_width"]
            else:
                return self.prototype["tile_height"]
        else:
            return aabb_to_dimensions(
                self.collision_set.get_bounding_box() if self.collision_set else None
            )[1]

    # =========================================================================

    def _set_direction(self, attr: attrs.Attribute, value: Any):
        value = attr.converter(value)
        attr.validator(self, attr, value)
        object.__setattr__(self, "direction", value)  # Prevent recursion

        if not self.square:
            self.tile_position = self.tile_position

        return value

    direction: Direction = attrs.field(
        default=Direction.NORTH,
        converter=try_convert(Direction),
        validator=instance_of(Direction),
        on_setattr=_set_direction,
    )
    """
    The direction that the Entity is facing. An Entity's "front" is usually
    the direction of it's outputs, if it has any.

    For some entities, this attribute may be redundant; for example, the
    direction value for an :py:class:`.AssemblingMachine` only matters if
    the machine has a fluid input or output.

    Raises :py:class:`~draftsman.warning.DirectionWarning` if set to a
    diagonal direction. In that case, the direction will default to the
    closest valid direction going counter-clockwise.

    :exception DraftsmanError: If the direction is set while inside a
        Collection, and the target entity is both non-square and the
        particular rotation would change it's apparent tile width and height.
        See, :ref:`here<handbook.blueprints.forbidden_entity_attributes>`
        for more info.
    :exception ValueError: If set to anything other than a ``Direction``, or
        an equivalent ``int``.
    """

    @direction.validator
    @conditional(ValidationMode.STRICT)
    def _direction_validator(
        self,
        _attr: attrs.Attribute,
        value: Direction,
    ):
        """
        Ensure the given direction matches one of :py:attr:`.valid_directions`.
        """
        if value not in self.valid_directions:
            # TODO: should we convert it for the user, or let it be wrong?
            msg = "Direction '{}' is disallowed for '{}' entities; only the following directions are permitted:\n\t{}".format(
                value.name, type(self).__name__, self.valid_directions
            )
            warnings.warn(DirectionWarning(msg))

    # =========================================================================

    def mergable_with(self, other: "Entity") -> bool:
        base_mergable = super().mergable_with(other)
        return base_mergable and self.direction == other.direction


draftsman_converters.add_hook_fns(
    DirectionalMixin,
    lambda fields: {"direction": fields.direction.name},
)
